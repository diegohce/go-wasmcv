// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package features2d represents the imported interface "wasm:cv/features2d".
package features2d

import (
	"go.bytecodealliance.org/cm"
	"wasmcv.org/wasm/cv/mat"
	"wasmcv.org/wasm/cv/types"
)

// Mat represents the imported type alias "wasm:cv/features2d#mat".
//
// See [mat.Mat] for more information.
type Mat = mat.Mat

// KeyPoint represents the type alias "wasm:cv/features2d#key-point".
//
// See [types.KeyPoint] for more information.
type KeyPoint = types.KeyPoint

// DMatch represents the type alias "wasm:cv/features2d#d-match".
//
// See [types.DMatch] for more information.
type DMatch = types.DMatch

// DetectorResult represents the imported record "wasm:cv/features2d#detector-result".
//
// rect is a rectangle with integer coordinates.
// It is represented by the top-left corner and the bottom-right corner.
//
//	record detector-result {
//		kps: list<key-point>,
//		desc: mat,
//	}
type DetectorResult struct {
	_    cm.HostLayout
	Kps  cm.List[KeyPoint]
	Desc Mat
}

// AKAZEDetector represents the imported resource "wasm:cv/features2d#AKAZE-detector".
//
// AKAZE-detector is a wrapper around the cv::AKAZE algorithm.
//
//	resource AKAZE-detector
type AKAZEDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "AKAZE-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self AKAZEDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_AKAZEDetectorResourceDrop((uint32)(self0))
	return
}

// NewAKAZEDetector represents the imported constructor for resource "AKAZE-detector".
//
// Returns a new akaze-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d8/d30/classcv_1_1AKAZE.html
//
//	constructor(name: string)
//
//go:nosplit
func NewAKAZEDetector(name string) (result AKAZEDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewAKAZEDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[AKAZEDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the akaze-detector
//
//	close: func()
//
//go:nosplit
func (self AKAZEDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_AKAZEDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using AKAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self AKAZEDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_AKAZEDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using AKAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self AKAZEDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_AKAZEDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using AKAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self AKAZEDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_AKAZEDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// BRISKDetector represents the imported resource "wasm:cv/features2d#BRISK-detector".
//
// BRISK-detector is a wrapper around the cv::BRISK algorithm.
//
//	resource BRISK-detector
type BRISKDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "BRISK-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self BRISKDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BRISKDetectorResourceDrop((uint32)(self0))
	return
}

// NewBRISKDetector represents the imported constructor for resource "BRISK-detector".
//
// Returns a new BRISK-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/de/dbf/classcv_1_1BRISK.html
//
//	constructor(name: string)
//
//go:nosplit
func NewBRISKDetector(name string) (result BRISKDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewBRISKDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[BRISKDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the BRISK-detector
//
//	close: func()
//
//go:nosplit
func (self BRISKDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BRISKDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using BRISK.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self BRISKDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_BRISKDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using BRISK.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self BRISKDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_BRISKDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using BRISK.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self BRISKDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_BRISKDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// KAZEDetector represents the imported resource "wasm:cv/features2d#KAZE-detector".
//
// KAZE-detector is a wrapper around the cv::KAZE algorithm.
//
//	resource KAZE-detector
type KAZEDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "KAZE-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self KAZEDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_KAZEDetectorResourceDrop((uint32)(self0))
	return
}

// NewKAZEDetector represents the imported constructor for resource "KAZE-detector".
//
// Returns a new KAZE-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d3/d61/classcv_1_1KAZE.html
//
//	constructor(name: string)
//
//go:nosplit
func NewKAZEDetector(name string) (result KAZEDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewKAZEDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[KAZEDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the KAZE-detector
//
//	close: func()
//
//go:nosplit
func (self KAZEDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_KAZEDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using KAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self KAZEDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_KAZEDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using KAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self KAZEDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_KAZEDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using KAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self KAZEDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_KAZEDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// ORBDetector represents the imported resource "wasm:cv/features2d#ORB-detector".
//
// ORB-detector is a wrapper around the cv::ORB algorithm.
//
//	resource ORB-detector
type ORBDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "ORB-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self ORBDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_ORBDetectorResourceDrop((uint32)(self0))
	return
}

// NewORBDetector represents the imported constructor for resource "ORB-detector".
//
// Returns a new ORB-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d95/classcv_1_1ORB.html
//
//	constructor(name: string)
//
//go:nosplit
func NewORBDetector(name string) (result ORBDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewORBDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[ORBDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the ORB-detector
//
//	close: func()
//
//go:nosplit
func (self ORBDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_ORBDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using ORB.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self ORBDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_ORBDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using ORB.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self ORBDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_ORBDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using ORB.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self ORBDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_ORBDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// SIFTDetector represents the imported resource "wasm:cv/features2d#SIFT-detector".
//
// SIFT-detector is a wrapper around the cv::SIFT algorithm.
//
//	resource SIFT-detector
type SIFTDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "SIFT-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self SIFTDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_SIFTDetectorResourceDrop((uint32)(self0))
	return
}

// NewSIFTDetector represents the imported constructor for resource "SIFT-detector".
//
// Returns a new SIFT-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d7/d60/classcv_1_1SIFT.html
//
//	constructor(name: string)
//
//go:nosplit
func NewSIFTDetector(name string) (result SIFTDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewSIFTDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[SIFTDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the SIFT-detector
//
//	close: func()
//
//go:nosplit
func (self SIFTDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_SIFTDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using SIFT.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self SIFTDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_SIFTDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using SIFT.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self SIFTDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_SIFTDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using SIFT.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self SIFTDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_SIFTDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// BFMatcher represents the imported resource "wasm:cv/features2d#BF-matcher".
//
// BF-matcher is a wrapper around the cv::BFMatcher algorithm.
//
//	resource BF-matcher
type BFMatcher cm.Resource

// ResourceDrop represents the imported resource-drop for resource "BF-matcher".
//
// Drops a resource handle.
//
//go:nosplit
func (self BFMatcher) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BFMatcherResourceDrop((uint32)(self0))
	return
}

// NewBFMatcher represents the imported constructor for resource "BF-matcher".
//
// Returns a new BF-matcher.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d3/da1/classcv_1_1BFMatcher.html#abe0bb11749b30d97f60d6ade665617bd
//
//	constructor(name: string)
//
//go:nosplit
func NewBFMatcher(name string) (result BFMatcher) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewBFMatcher((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[BFMatcher]((uint32)(result0))
	return
}

// KNNMatch represents the imported method "KNN-match".
//
// KNNMatch finds the k best matches for each descriptor from a query set.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d39/classcv_1_1DescriptorMatcher.html#aa880f9353cdf185ccf3013e08210483a
//
//	KNN-match: func(query: mat, train: mat, k: u32) -> list<list<d-match>>
//
//go:nosplit
func (self BFMatcher) KNNMatch(query Mat, train Mat, k uint32) (result cm.List[cm.List[DMatch]]) {
	self0 := cm.Reinterpret[uint32](self)
	query0 := cm.Reinterpret[uint32](query)
	train0 := cm.Reinterpret[uint32](train)
	k0 := (uint32)(k)
	wasmimport_BFMatcherKNNMatch((uint32)(self0), (uint32)(query0), (uint32)(train0), (uint32)(k0), &result)
	return
}

// Close represents the imported method "close".
//
// Close the BF-matcher
//
//	close: func()
//
//go:nosplit
func (self BFMatcher) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BFMatcherClose((uint32)(self0))
	return
}

// Match represents the imported method "match".
//
// Match Finds the best match for each descriptor from a query set.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d39/classcv_1_1DescriptorMatcher.html#a0f046f47b68ec7074391e1e85c750cba
//
//	match: func(query: mat, train: mat) -> list<d-match>
//
//go:nosplit
func (self BFMatcher) Match(query Mat, train Mat) (result cm.List[DMatch]) {
	self0 := cm.Reinterpret[uint32](self)
	query0 := cm.Reinterpret[uint32](query)
	train0 := cm.Reinterpret[uint32](train)
	wasmimport_BFMatcherMatch((uint32)(self0), (uint32)(query0), (uint32)(train0), &result)
	return
}

// FlannBasedMatcher represents the imported resource "wasm:cv/features2d#flann-based-matcher".
//
// Flann-based-matcher is a wrapper around the cv::BFMatcher algorithm.
//
//	resource flann-based-matcher
type FlannBasedMatcher cm.Resource

// ResourceDrop represents the imported resource-drop for resource "flann-based-matcher".
//
// Drops a resource handle.
//
//go:nosplit
func (self FlannBasedMatcher) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FlannBasedMatcherResourceDrop((uint32)(self0))
	return
}

// NewFlannBasedMatcher represents the imported constructor for resource "flann-based-matcher".
//
// Returns a new flann-based-matcher.
//
// For further details, please see:
// https://docs.opencv.org/4.x/dc/de2/classcv_1_1FlannBasedMatcher.html#ab9114a6471e364ad221f89068ca21382
//
//	constructor(name: string)
//
//go:nosplit
func NewFlannBasedMatcher(name string) (result FlannBasedMatcher) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewFlannBasedMatcher((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[FlannBasedMatcher]((uint32)(result0))
	return
}

// KNNMatch represents the imported method "KNN-match".
//
// KNNMatch finds the k best matches for each descriptor from a query set.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d39/classcv_1_1DescriptorMatcher.html#aa880f9353cdf185ccf3013e08210483a
//
//	KNN-match: func(query: mat, train: mat, k: u32) -> list<list<d-match>>
//
//go:nosplit
func (self FlannBasedMatcher) KNNMatch(query Mat, train Mat, k uint32) (result cm.List[cm.List[DMatch]]) {
	self0 := cm.Reinterpret[uint32](self)
	query0 := cm.Reinterpret[uint32](query)
	train0 := cm.Reinterpret[uint32](train)
	k0 := (uint32)(k)
	wasmimport_FlannBasedMatcherKNNMatch((uint32)(self0), (uint32)(query0), (uint32)(train0), (uint32)(k0), &result)
	return
}

// Close represents the imported method "close".
//
// Close the flann-based-matcher
//
//	close: func()
//
//go:nosplit
func (self FlannBasedMatcher) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FlannBasedMatcherClose((uint32)(self0))
	return
}
