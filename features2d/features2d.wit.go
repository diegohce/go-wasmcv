// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package features2d represents the imported interface "wasm:cv/features2d".
package features2d

import (
	"go.bytecodealliance.org/cm"
	"wasmcv.org/wasm/cv/mat"
	"wasmcv.org/wasm/cv/types"
)

// Mat represents the imported type alias "wasm:cv/features2d#mat".
//
// See [mat.Mat] for more information.
type Mat = mat.Mat

// KeyPoint represents the type alias "wasm:cv/features2d#key-point".
//
// See [types.KeyPoint] for more information.
type KeyPoint = types.KeyPoint

// DMatch represents the type alias "wasm:cv/features2d#d-match".
//
// See [types.DMatch] for more information.
type DMatch = types.DMatch

// DetectorResult represents the imported record "wasm:cv/features2d#detector-result".
//
// detector-result returns the keypoints and descripts for a detector.
//
//	record detector-result {
//		kps: list<key-point>,
//		desc: mat,
//	}
type DetectorResult struct {
	_    cm.HostLayout     `json:"-"`
	Kps  cm.List[KeyPoint] `json:"kps"`
	Desc Mat               `json:"desc"`
}

// AKAZEDetector represents the imported resource "wasm:cv/features2d#AKAZE-detector".
//
// AKAZE-detector is a wrapper around the cv::AKAZE algorithm.
//
//	resource AKAZE-detector
type AKAZEDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "AKAZE-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self AKAZEDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_AKAZEDetectorResourceDrop((uint32)(self0))
	return
}

// NewAKAZEDetector represents the imported constructor for resource "AKAZE-detector".
//
// Returns a new akaze-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d8/d30/classcv_1_1AKAZE.html
//
//	constructor(name: string)
//
//go:nosplit
func NewAKAZEDetector(name string) (result AKAZEDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewAKAZEDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[AKAZEDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the akaze-detector
//
//	close: func()
//
//go:nosplit
func (self AKAZEDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_AKAZEDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using AKAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self AKAZEDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_AKAZEDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using AKAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self AKAZEDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_AKAZEDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using AKAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self AKAZEDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_AKAZEDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// BRISKDetector represents the imported resource "wasm:cv/features2d#BRISK-detector".
//
// BRISK-detector is a wrapper around the cv::BRISK algorithm.
//
//	resource BRISK-detector
type BRISKDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "BRISK-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self BRISKDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BRISKDetectorResourceDrop((uint32)(self0))
	return
}

// NewBRISKDetector represents the imported constructor for resource "BRISK-detector".
//
// Returns a new BRISK-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/de/dbf/classcv_1_1BRISK.html
//
//	constructor(name: string)
//
//go:nosplit
func NewBRISKDetector(name string) (result BRISKDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewBRISKDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[BRISKDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the BRISK-detector
//
//	close: func()
//
//go:nosplit
func (self BRISKDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BRISKDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using BRISK.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self BRISKDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_BRISKDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using BRISK.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self BRISKDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_BRISKDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using BRISK.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self BRISKDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_BRISKDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// KAZEDetector represents the imported resource "wasm:cv/features2d#KAZE-detector".
//
// KAZE-detector is a wrapper around the cv::KAZE algorithm.
//
//	resource KAZE-detector
type KAZEDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "KAZE-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self KAZEDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_KAZEDetectorResourceDrop((uint32)(self0))
	return
}

// NewKAZEDetector represents the imported constructor for resource "KAZE-detector".
//
// Returns a new KAZE-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d3/d61/classcv_1_1KAZE.html
//
//	constructor(name: string)
//
//go:nosplit
func NewKAZEDetector(name string) (result KAZEDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewKAZEDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[KAZEDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the KAZE-detector
//
//	close: func()
//
//go:nosplit
func (self KAZEDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_KAZEDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using KAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self KAZEDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_KAZEDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using KAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self KAZEDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_KAZEDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using KAZE.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self KAZEDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_KAZEDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// ORBScoreType represents the enum "wasm:cv/features2d#ORB-score-type".
//
//	enum ORB-score-type {
//		ORB-HARRIS,
//		ORB-FAST
//	}
type ORBScoreType uint8

const (
	ORBScoreTypeORBHARRIS ORBScoreType = iota
	ORBScoreTypeORBFAST
)

var _ORBScoreTypeStrings = [2]string{
	"ORB-HARRIS",
	"ORB-FAST",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e ORBScoreType) String() string {
	return _ORBScoreTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e ORBScoreType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *ORBScoreType) UnmarshalText(text []byte) error {
	return _ORBScoreTypeUnmarshalCase(e, text)
}

var _ORBScoreTypeUnmarshalCase = cm.CaseUnmarshaler[ORBScoreType](_ORBScoreTypeStrings[:])

// ORBDetector represents the imported resource "wasm:cv/features2d#ORB-detector".
//
// ORB-detector is a wrapper around the cv::ORB algorithm.
//
//	resource ORB-detector
type ORBDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "ORB-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self ORBDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_ORBDetectorResourceDrop((uint32)(self0))
	return
}

// NewORBDetector represents the imported constructor for resource "ORB-detector".
//
// Returns a new ORB-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d95/classcv_1_1ORB.html
//
//	constructor(name: string)
//
//go:nosplit
func NewORBDetector(name string) (result ORBDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewORBDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[ORBDetector]((uint32)(result0))
	return
}

// ORBDetectorNewWithParams represents the imported static function "new-with-params".
//
// Returns a new ORB-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d95/classcv_1_1ORB.html
//
//	new-with-params: static func(features: u32, scale: f32, levels: u32, edge-threshold:
//	u32, first: u32, WTAK: u32, score-type: ORB-score-type, patch-size: u32, fast-threshold:
//	u32) -> ORB-detector
//
//go:nosplit
func ORBDetectorNewWithParams(features uint32, scale float32, levels uint32, edgeThreshold uint32, first uint32, wtak uint32, scoreType ORBScoreType, patchSize uint32, fastThreshold uint32) (result ORBDetector) {
	features0 := (uint32)(features)
	scale0 := (float32)(scale)
	levels0 := (uint32)(levels)
	edgeThreshold0 := (uint32)(edgeThreshold)
	first0 := (uint32)(first)
	wtak0 := (uint32)(wtak)
	scoreType0 := (uint32)(scoreType)
	patchSize0 := (uint32)(patchSize)
	fastThreshold0 := (uint32)(fastThreshold)
	result0 := wasmimport_ORBDetectorNewWithParams((uint32)(features0), (float32)(scale0), (uint32)(levels0), (uint32)(edgeThreshold0), (uint32)(first0), (uint32)(wtak0), (uint32)(scoreType0), (uint32)(patchSize0), (uint32)(fastThreshold0))
	result = cm.Reinterpret[ORBDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the ORB-detector
//
//	close: func()
//
//go:nosplit
func (self ORBDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_ORBDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using ORB.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self ORBDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_ORBDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using ORB.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self ORBDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_ORBDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using ORB.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self ORBDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_ORBDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// SIFTDetector represents the imported resource "wasm:cv/features2d#SIFT-detector".
//
// SIFT-detector is a wrapper around the cv::SIFT algorithm.
//
//	resource SIFT-detector
type SIFTDetector cm.Resource

// ResourceDrop represents the imported resource-drop for resource "SIFT-detector".
//
// Drops a resource handle.
//
//go:nosplit
func (self SIFTDetector) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_SIFTDetectorResourceDrop((uint32)(self0))
	return
}

// NewSIFTDetector represents the imported constructor for resource "SIFT-detector".
//
// Returns a new SIFT-detector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d7/d60/classcv_1_1SIFT.html
//
//	constructor(name: string)
//
//go:nosplit
func NewSIFTDetector(name string) (result SIFTDetector) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewSIFTDetector((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[SIFTDetector]((uint32)(result0))
	return
}

// Close represents the imported method "close".
//
// Close the SIFT-detector
//
//	close: func()
//
//go:nosplit
func (self SIFTDetector) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_SIFTDetectorClose((uint32)(self0))
	return
}

// Compute represents the imported method "compute".
//
// Compute keypoints in an image using SIFT.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#ab3cce8d56f4fc5e1d530b5931e1e8dc0
//
//	compute: func(src: mat, mask: mat, kps: list<key-point>) -> detector-result
//
//go:nosplit
func (self SIFTDetector) Compute(src Mat, mask Mat, kps cm.List[KeyPoint]) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	kps0, kps1 := cm.LowerList(kps)
	wasmimport_SIFTDetectorCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), (*KeyPoint)(kps0), (uint32)(kps1), &result)
	return
}

// Detect represents the imported method "detect".
//
// Detect keypoints in an image using SIFT.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#aa4e9a7082ec61ebc108806704fbd7887
//
//	detect: func(src: mat) -> list<key-point>
//
//go:nosplit
func (self SIFTDetector) Detect(src Mat) (result cm.List[KeyPoint]) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_SIFTDetectorDetect((uint32)(self0), (uint32)(src0), &result)
	return
}

// DetectAndCompute represents the imported method "detect-and-compute".
//
// DetectAndCompute keypoints and compute in an image using SIFT.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d0/d13/classcv_1_1Feature2D.html#a8be0d1c20b08eb867184b8d74c15a677
//
//	detect-and-compute: func(src: mat, mask: mat) -> detector-result
//
//go:nosplit
func (self SIFTDetector) DetectAndCompute(src Mat, mask Mat) (result DetectorResult) {
	self0 := cm.Reinterpret[uint32](self)
	src0 := cm.Reinterpret[uint32](src)
	mask0 := cm.Reinterpret[uint32](mask)
	wasmimport_SIFTDetectorDetectAndCompute((uint32)(self0), (uint32)(src0), (uint32)(mask0), &result)
	return
}

// NormType represents the enum "wasm:cv/features2d#norm-type".
//
//	enum norm-type {
//		NORM-NONE,
//		NONE-INF,
//		NORM-L1,
//		NORM-NONE2,
//		NORM-L2,
//		NORM-L2SQR,
//		NORM-HAMMING,
//		NORM-HAMMING2,
//		NORM-RELATIVE
//	}
type NormType uint8

const (
	NormTypeNORMNONE NormType = iota
	NormTypeNONEINF
	NormTypeNORML1
	NormTypeNORMNONE2
	NormTypeNORML2
	NormTypeNORML2SQR
	NormTypeNORMHAMMING
	NormTypeNORMHAMMING2
	NormTypeNORMRELATIVE
)

var _NormTypeStrings = [9]string{
	"NORM-NONE",
	"NONE-INF",
	"NORM-L1",
	"NORM-NONE2",
	"NORM-L2",
	"NORM-L2SQR",
	"NORM-HAMMING",
	"NORM-HAMMING2",
	"NORM-RELATIVE",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e NormType) String() string {
	return _NormTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e NormType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *NormType) UnmarshalText(text []byte) error {
	return _NormTypeUnmarshalCase(e, text)
}

var _NormTypeUnmarshalCase = cm.CaseUnmarshaler[NormType](_NormTypeStrings[:])

// BFMatcher represents the imported resource "wasm:cv/features2d#BF-matcher".
//
// BF-matcher is a wrapper around the cv::BFMatcher algorithm.
//
//	resource BF-matcher
type BFMatcher cm.Resource

// ResourceDrop represents the imported resource-drop for resource "BF-matcher".
//
// Drops a resource handle.
//
//go:nosplit
func (self BFMatcher) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BFMatcherResourceDrop((uint32)(self0))
	return
}

// NewBFMatcher represents the imported constructor for resource "BF-matcher".
//
// Returns a new BF-matcher.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d3/da1/classcv_1_1BFMatcher.html#abe0bb11749b30d97f60d6ade665617bd
//
//	constructor(name: string)
//
//go:nosplit
func NewBFMatcher(name string) (result BFMatcher) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewBFMatcher((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[BFMatcher]((uint32)(result0))
	return
}

// BFMatcherNewWithParams represents the imported static function "new-with-params".
//
// Returns a new BF-matcher.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d3/da1/classcv_1_1BFMatcher.html#abe0bb11749b30d97f60d6ade665617bd
//
//	new-with-params: static func(norm: norm-type, cross-check: bool) -> BF-matcher
//
//go:nosplit
func BFMatcherNewWithParams(norm NormType, crossCheck bool) (result BFMatcher) {
	norm0 := (uint32)(norm)
	crossCheck0 := (uint32)(cm.BoolToU32(crossCheck))
	result0 := wasmimport_BFMatcherNewWithParams((uint32)(norm0), (uint32)(crossCheck0))
	result = cm.Reinterpret[BFMatcher]((uint32)(result0))
	return
}

// KNNMatch represents the imported method "KNN-match".
//
// KNNMatch finds the k best matches for each descriptor from a query set.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d39/classcv_1_1DescriptorMatcher.html#aa880f9353cdf185ccf3013e08210483a
//
//	KNN-match: func(query: mat, train: mat, k: u32) -> list<list<d-match>>
//
//go:nosplit
func (self BFMatcher) KNNMatch(query Mat, train Mat, k uint32) (result cm.List[cm.List[DMatch]]) {
	self0 := cm.Reinterpret[uint32](self)
	query0 := cm.Reinterpret[uint32](query)
	train0 := cm.Reinterpret[uint32](train)
	k0 := (uint32)(k)
	wasmimport_BFMatcherKNNMatch((uint32)(self0), (uint32)(query0), (uint32)(train0), (uint32)(k0), &result)
	return
}

// Close represents the imported method "close".
//
// Close the BF-matcher
//
//	close: func()
//
//go:nosplit
func (self BFMatcher) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_BFMatcherClose((uint32)(self0))
	return
}

// Match represents the imported method "match".
//
// Match Finds the best match for each descriptor from a query set.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d39/classcv_1_1DescriptorMatcher.html#a0f046f47b68ec7074391e1e85c750cba
//
//	match: func(query: mat, train: mat) -> list<d-match>
//
//go:nosplit
func (self BFMatcher) Match(query Mat, train Mat) (result cm.List[DMatch]) {
	self0 := cm.Reinterpret[uint32](self)
	query0 := cm.Reinterpret[uint32](query)
	train0 := cm.Reinterpret[uint32](train)
	wasmimport_BFMatcherMatch((uint32)(self0), (uint32)(query0), (uint32)(train0), &result)
	return
}

// FlannBasedMatcher represents the imported resource "wasm:cv/features2d#flann-based-matcher".
//
// Flann-based-matcher is a wrapper around the cv::BFMatcher algorithm.
//
//	resource flann-based-matcher
type FlannBasedMatcher cm.Resource

// ResourceDrop represents the imported resource-drop for resource "flann-based-matcher".
//
// Drops a resource handle.
//
//go:nosplit
func (self FlannBasedMatcher) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FlannBasedMatcherResourceDrop((uint32)(self0))
	return
}

// NewFlannBasedMatcher represents the imported constructor for resource "flann-based-matcher".
//
// Returns a new flann-based-matcher.
//
// For further details, please see:
// https://docs.opencv.org/4.x/dc/de2/classcv_1_1FlannBasedMatcher.html#ab9114a6471e364ad221f89068ca21382
//
//	constructor(name: string)
//
//go:nosplit
func NewFlannBasedMatcher(name string) (result FlannBasedMatcher) {
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_NewFlannBasedMatcher((*uint8)(name0), (uint32)(name1))
	result = cm.Reinterpret[FlannBasedMatcher]((uint32)(result0))
	return
}

// KNNMatch represents the imported method "KNN-match".
//
// KNNMatch finds the k best matches for each descriptor from a query set.
//
// For further details, please see:
// https://docs.opencv.org/4.x/db/d39/classcv_1_1DescriptorMatcher.html#aa880f9353cdf185ccf3013e08210483a
//
//	KNN-match: func(query: mat, train: mat, k: u32) -> list<list<d-match>>
//
//go:nosplit
func (self FlannBasedMatcher) KNNMatch(query Mat, train Mat, k uint32) (result cm.List[cm.List[DMatch]]) {
	self0 := cm.Reinterpret[uint32](self)
	query0 := cm.Reinterpret[uint32](query)
	train0 := cm.Reinterpret[uint32](train)
	k0 := (uint32)(k)
	wasmimport_FlannBasedMatcherKNNMatch((uint32)(self0), (uint32)(query0), (uint32)(train0), (uint32)(k0), &result)
	return
}

// Close represents the imported method "close".
//
// Close the flann-based-matcher
//
//	close: func()
//
//go:nosplit
func (self FlannBasedMatcher) Close() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FlannBasedMatcherClose((uint32)(self0))
	return
}
