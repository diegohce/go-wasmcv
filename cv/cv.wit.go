// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package cv represents the imported interface "wasm:cv/cv".
package cv

import (
	"go.bytecodealliance.org/cm"
	"wasmcv.org/wasm/cv/mat"
	"wasmcv.org/wasm/cv/types"
)

// ErrorResult represents the type alias "wasm:cv/cv#error-result".
//
// See [types.ErrorResult] for more information.
type ErrorResult = types.ErrorResult

// BorderType represents the type alias "wasm:cv/cv#border-type".
//
// See [types.BorderType] for more information.
type BorderType = types.BorderType

// Size represents the type alias "wasm:cv/cv#size".
//
// See [types.Size] for more information.
type Size = types.Size

// Point represents the type alias "wasm:cv/cv#point".
//
// See [types.Point] for more information.
type Point = types.Point

// AdaptiveThresholdType represents the type alias "wasm:cv/cv#adaptive-threshold-type".
//
// See [types.AdaptiveThresholdType] for more information.
type AdaptiveThresholdType = types.AdaptiveThresholdType

// ThresholdType represents the type alias "wasm:cv/cv#threshold-type".
//
// See [types.ThresholdType] for more information.
type ThresholdType = types.ThresholdType

// Scalar represents the type alias "wasm:cv/cv#scalar".
//
// See [types.Scalar] for more information.
type Scalar = types.Scalar

// Rect represents the type alias "wasm:cv/cv#rect".
//
// See [types.Rect] for more information.
type Rect = types.Rect

// RGBA represents the type alias "wasm:cv/cv#RGBA".
//
// See [types.RGBA] for more information.
type RGBA = types.RGBA

// HersheyFontType represents the type alias "wasm:cv/cv#hershey-font-type".
//
// See [types.HersheyFontType] for more information.
type HersheyFontType = types.HersheyFontType

// InterpolationType represents the type alias "wasm:cv/cv#interpolation-type".
//
// See [types.InterpolationType] for more information.
type InterpolationType = types.InterpolationType

// ColorCoversionType represents the type alias "wasm:cv/cv#color-coversion-type".
//
// See [types.ColorCoversionType] for more information.
type ColorCoversionType = types.ColorCoversionType

// MorphShape represents the type alias "wasm:cv/cv#morph-shape".
//
// See [types.MorphShape] for more information.
type MorphShape = types.MorphShape

// Mat represents the imported type alias "wasm:cv/cv#mat".
//
// See [mat.Mat] for more information.
type Mat = mat.Mat

// Mattype represents the type alias "wasm:cv/cv#mattype".
//
// See [mat.Mattype] for more information.
type Mattype = mat.Mattype

// ArrowedLine represents the imported function "arrowed-line".
//
// drawing functions
// ArrowedLine draws a arrow segment pointing from the first point to the second one.
//
// For further details, please see:
// https://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#ga0a165a3ca093fd488ac709fdf10c05b2
//
//	arrowed-line: func(img: borrow<mat>, point1: point, point2: point, c: RGBA, thickness:
//	u8) -> result<_, error-result>
//
//go:nosplit
func ArrowedLine(img Mat, point1 Point, point2 Point, c RGBA, thickness uint8) (result cm.Result[ErrorResult, struct{}, ErrorResult]) {
	img0 := cm.Reinterpret[uint32](img)
	point10, point11 := lower_Size(point1)
	point20, point21 := lower_Size(point2)
	c0, c1, c2, c3 := lower_RGBA(c)
	thickness0 := (uint32)(thickness)
	wasmimport_ArrowedLine((uint32)(img0), (uint32)(point10), (uint32)(point11), (uint32)(point20), (uint32)(point21), (uint32)(c0), (uint32)(c1), (uint32)(c2), (uint32)(c3), (uint32)(thickness0), &result)
	return
}

// Rectangle represents the imported function "rectangle".
//
// Rectangle draws a simple, thick, or filled up-right rectangle.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8f3d1e1b7
//
//	rectangle: func(img: borrow<mat>, r: rect, c: RGBA, thickness: u8) -> result<_,
//	error-result>
//
//go:nosplit
func Rectangle(img Mat, r Rect, c RGBA, thickness uint8) (result cm.Result[ErrorResult, struct{}, ErrorResult]) {
	img0 := cm.Reinterpret[uint32](img)
	r0, r1, r2, r3 := lower_Rect(r)
	c0, c1, c2, c3 := lower_RGBA(c)
	thickness0 := (uint32)(thickness)
	wasmimport_Rectangle((uint32)(img0), (uint32)(r0), (uint32)(r1), (uint32)(r2), (uint32)(r3), (uint32)(c0), (uint32)(c1), (uint32)(c2), (uint32)(c3), (uint32)(thickness0), &result)
	return
}

// Circle represents the imported function "circle".
//
// Circle draws a circle.
//
// For further details, please see:
// https://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670
//
//	circle: func(img: borrow<mat>, center: point, radius: u32, c: RGBA, thickness:
//	u8) -> result<_, error-result>
//
//go:nosplit
func Circle(img Mat, center Point, radius uint32, c RGBA, thickness uint8) (result cm.Result[ErrorResult, struct{}, ErrorResult]) {
	img0 := cm.Reinterpret[uint32](img)
	center0, center1 := lower_Size(center)
	radius0 := (uint32)(radius)
	c0, c1, c2, c3 := lower_RGBA(c)
	thickness0 := (uint32)(thickness)
	wasmimport_Circle((uint32)(img0), (uint32)(center0), (uint32)(center1), (uint32)(radius0), (uint32)(c0), (uint32)(c1), (uint32)(c2), (uint32)(c3), (uint32)(thickness0), &result)
	return
}

// Line represents the imported function "line".
//
// Line draws a line segment connecting two points.
//
// For further details, please see:
// https://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2
//
//	line: func(img: borrow<mat>, point1: point, point2: point, c: RGBA, thickness:
//	u8) -> result<_, error-result>
//
//go:nosplit
func Line(img Mat, point1 Point, point2 Point, c RGBA, thickness uint8) (result cm.Result[ErrorResult, struct{}, ErrorResult]) {
	img0 := cm.Reinterpret[uint32](img)
	point10, point11 := lower_Size(point1)
	point20, point21 := lower_Size(point2)
	c0, c1, c2, c3 := lower_RGBA(c)
	thickness0 := (uint32)(thickness)
	wasmimport_Line((uint32)(img0), (uint32)(point10), (uint32)(point11), (uint32)(point20), (uint32)(point21), (uint32)(c0), (uint32)(c1), (uint32)(c2), (uint32)(c3), (uint32)(thickness0), &result)
	return
}

// PutText represents the imported function "put-text".
//
// PutText draws a text string.
// It renders the specified text string into the img Mat at the location
// passed in the "org" param, using the desired font face, font scale,
// color, and line thinkness.
//
// For further details, please see:
// http://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576
//
//	put-text: func(img: borrow<mat>, text: string, org: point, font-face: hershey-font-type,
//	font-scale: f64, c: RGBA, thickness: s32) -> result<_, error-result>
//
//go:nosplit
func PutText(img Mat, text string, org Point, fontFace HersheyFontType, fontScale float64, c RGBA, thickness int32) (result cm.Result[ErrorResult, struct{}, ErrorResult]) {
	img0 := cm.Reinterpret[uint32](img)
	text0, text1 := cm.LowerString(text)
	org0, org1 := lower_Size(org)
	fontFace0 := (uint32)(fontFace)
	fontScale0 := (float64)(fontScale)
	c0, c1, c2, c3 := lower_RGBA(c)
	thickness0 := (uint32)(thickness)
	wasmimport_PutText((uint32)(img0), (*uint8)(text0), (uint32)(text1), (uint32)(org0), (uint32)(org1), (uint32)(fontFace0), (float64)(fontScale0), (uint32)(c0), (uint32)(c1), (uint32)(c2), (uint32)(c3), (uint32)(thickness0), &result)
	return
}

// AdaptiveThreshold represents the imported function "adaptive-threshold".
//
// imgproc functions
// AdaptiveThreshold applies a fixed-level threshold to each array element.
//
// For further details, please see:
// https://docs.opencv.org/master/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3
//
//	adaptive-threshold: func(src: mat, max-value: f32, adaptive-type: adaptive-threshold-type,
//	threshold-type: threshold-type, block-size: u32, c: f32) -> result<mat, error-result>
//
//go:nosplit
func AdaptiveThreshold(src Mat, maxValue float32, adaptiveType AdaptiveThresholdType, thresholdType ThresholdType, blockSize uint32, c float32) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	maxValue0 := (float32)(maxValue)
	adaptiveType0 := (uint32)(adaptiveType)
	thresholdType0 := (uint32)(thresholdType)
	blockSize0 := (uint32)(blockSize)
	c0 := (float32)(c)
	wasmimport_AdaptiveThreshold((uint32)(src0), (float32)(maxValue0), (uint32)(adaptiveType0), (uint32)(thresholdType0), (uint32)(blockSize0), (float32)(c0), &result)
	return
}

// Blur represents the imported function "blur".
//
// Blur blurs an image Mat using a normalized box filter.
//
// For further details, please see:
// https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37
//
//	blur: func(src: mat, k-size: size) -> result<mat, error-result>
//
//go:nosplit
func Blur(src Mat, kSize Size) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	kSize0, kSize1 := lower_Size(kSize)
	wasmimport_Blur((uint32)(src0), (uint32)(kSize0), (uint32)(kSize1), &result)
	return
}

// BoxFilter represents the imported function "box-filter".
//
// BoxFilter blurs an image using the box filter.
//
// For further details, please see:
// https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3
//
//	box-filter: func(src: mat, depth: u32, k-size: size) -> result<mat, error-result>
//
//go:nosplit
func BoxFilter(src Mat, depth uint32, kSize Size) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	depth0 := (uint32)(depth)
	kSize0, kSize1 := lower_Size(kSize)
	wasmimport_BoxFilter((uint32)(src0), (uint32)(depth0), (uint32)(kSize0), (uint32)(kSize1), &result)
	return
}

// Canny represents the imported function "canny".
//
// Canny finds edges in an image using the Canny algorithm.
// The function finds edges in the input image image and marks
// them in the output map edges using the Canny algorithm.
// The smallest value between threshold1 and threshold2 is used
// for edge linking. The largest value is used to
// find initial segments of strong edges.
// See http://en.wikipedia.org/wiki/Canny_edge_detector
//
// For further details, please see:
// http://docs.opencv.org/master/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de
//
//	canny: func(src: mat, threshold1: f32, threshold2: f32) -> result<mat, error-result>
//
//go:nosplit
func Canny(src Mat, threshold1 float32, threshold2 float32) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	threshold10 := (float32)(threshold1)
	threshold20 := (float32)(threshold2)
	wasmimport_Canny((uint32)(src0), (float32)(threshold10), (float32)(threshold20), &result)
	return
}

// CvtColor represents the imported function "cvt-color".
//
// CvtColor converts an image from one color space to another.
//
// For further details, please see:
// http://docs.opencv.org/master/d7/d1b/group__imgproc__misc.html#ga4e0972be5de079fed4e3a10e24ef5ef0
//
//	cvt-color: func(src: mat, code: color-coversion-type) -> result<mat, error-result>
//
//go:nosplit
func CvtColor(src Mat, code ColorCoversionType) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	code0 := (uint32)(code)
	wasmimport_CvtColor((uint32)(src0), (uint32)(code0), &result)
	return
}

// Dilate represents the imported function "dilate".
//
// Dilate dilates an image by using a specific structuring element.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c
//
//	dilate: func(src: mat, kernel: mat) -> result<mat, error-result>
//
//go:nosplit
func Dilate(src Mat, kernel Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	kernel0 := cm.Reinterpret[uint32](kernel)
	wasmimport_Dilate((uint32)(src0), (uint32)(kernel0), &result)
	return
}

// Erode represents the imported function "erode".
//
// Erode erodes an image by using a specific structuring element.
//
// For further details, please see:
// https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb
//
//	erode: func(src: mat, kernel: mat) -> result<mat, error-result>
//
//go:nosplit
func Erode(src Mat, kernel Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	kernel0 := cm.Reinterpret[uint32](kernel)
	wasmimport_Erode((uint32)(src0), (uint32)(kernel0), &result)
	return
}

// EqualizeHist represents the imported function "equalize-hist".
//
// EqualizeHist normalizes the brightness and increases the contrast of the image.
//
// For further details, please see:
// https://docs.opencv.org/master/d6/dc7/group__imgproc__hist.html#ga7e54091f0c937d49bf84152a16f76d6e
//
//	equalize-hist: func(src: mat) -> result<mat, error-result>
//
//go:nosplit
func EqualizeHist(src Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_EqualizeHist((uint32)(src0), &result)
	return
}

// GaussianBlur represents the imported function "gaussian-blur".
//
// GaussianBlur blurs an image using a Gaussian filter.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gae8bdcd9154ed5ca3cbc1766d960f45c1
//
//	gaussian-blur: func(src: mat, size: size, sigma-x: f32, sigma-y: f32, border: border-type)
//	-> result<mat, error-result>
//
//go:nosplit
func GaussianBlur(src Mat, size Size, sigmaX float32, sigmaY float32, border BorderType) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	size0, size1 := lower_Size(size)
	sigmaX0 := (float32)(sigmaX)
	sigmaY0 := (float32)(sigmaY)
	border0 := (uint32)(border)
	wasmimport_GaussianBlur((uint32)(src0), (uint32)(size0), (uint32)(size1), (float32)(sigmaX0), (float32)(sigmaY0), (uint32)(border0), &result)
	return
}

// GetStructuringElement represents the imported function "get-structuring-element".
//
// GetStructuringElement returns a structuring element of the specified size
// and shape for morphological operations.
//
// For further details, please see:
// https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc
//
//	get-structuring-element: func(shape: morph-shape, size: size) -> result<mat, error-result>
//
//go:nosplit
func GetStructuringElement(shape MorphShape, size Size) (result cm.Result[string, Mat, ErrorResult]) {
	shape0 := (uint32)(shape)
	size0, size1 := lower_Size(size)
	wasmimport_GetStructuringElement((uint32)(shape0), (uint32)(size0), (uint32)(size1), &result)
	return
}

// HoughLines represents the imported function "hough-lines".
//
// HoughLines implements the standard or standard multi-scale Hough transform
// algorithm for line detection. For a good explanation of Hough transform, see:
// http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm
//
// For further details, please see:
// http://docs.opencv.org/master/dd/d1a/group__imgproc__feature.html#ga46b4e588934f6c8dfd509cc6e0e4545a
//
//	hough-lines: func(src: mat, rho: f64, theta: f64, threshold: s32) -> result<mat,
//	error-result>
//
//go:nosplit
func HoughLines(src Mat, rho float64, theta float64, threshold int32) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	rho0 := (float64)(rho)
	theta0 := (float64)(theta)
	threshold0 := (uint32)(threshold)
	wasmimport_HoughLines((uint32)(src0), (float64)(rho0), (float64)(theta0), (uint32)(threshold0), &result)
	return
}

// HoughLinesP represents the imported function "hough-lines-p".
//
// HoughLinesP implements the probabilistic Hough transform
// algorithm for line detection. For a good explanation of Hough transform, see:
// http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm
//
// For further details, please see:
// http://docs.opencv.org/master/dd/d1a/group__imgproc__feature.html#ga8618180a5948286384e3b7ca02f6feeb
//
//	hough-lines-p: func(src: mat, rho: f64, theta: f64, threshold: s32) -> result<mat,
//	error-result>
//
//go:nosplit
func HoughLinesP(src Mat, rho float64, theta float64, threshold int32) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	rho0 := (float64)(rho)
	theta0 := (float64)(theta)
	threshold0 := (uint32)(threshold)
	wasmimport_HoughLinesP((uint32)(src0), (float64)(rho0), (float64)(theta0), (uint32)(threshold0), &result)
	return
}

// MedianBlur represents the imported function "median-blur".
//
// MedianBlur blurs an image using the median filter.
//
// For further details, please see:
// https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9
//
//	median-blur: func(src: mat, k-size: size) -> result<mat, error-result>
//
//go:nosplit
func MedianBlur(src Mat, kSize Size) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	kSize0, kSize1 := lower_Size(kSize)
	wasmimport_MedianBlur((uint32)(src0), (uint32)(kSize0), (uint32)(kSize1), &result)
	return
}

// Resize represents the imported function "resize".
//
// Resize resizes an image.
// It resizes the image src down to or up to the specified size, storing the
// result in dst. Note that src and dst may be the same image. If you wish to
// scale by factor, an empty sz may be passed and non-zero fx and fy. Likewise,
// if you wish to scale to an explicit size, a non-empty sz may be passed with
// zero for both fx and fy.
//
// For further details, please see:
// https://docs.opencv.org/master/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d
//
//	resize: func(src: mat, size: size, fx: f32, fy: f32, interp: interpolation-type)
//	-> result<mat, error-result>
//
//go:nosplit
func Resize(src Mat, size Size, fx float32, fy float32, interp InterpolationType) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	size0, size1 := lower_Size(size)
	fx0 := (float32)(fx)
	fy0 := (float32)(fy)
	interp0 := (uint32)(interp)
	wasmimport_Resize((uint32)(src0), (uint32)(size0), (uint32)(size1), (float32)(fx0), (float32)(fy0), (uint32)(interp0), &result)
	return
}

// Threshold represents the imported function "threshold".
//
// Threshold applies a fixed-level threshold to each array element.
//
// For further details, please see:
// https://docs.opencv.org/3.3.0/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57
//
//	threshold: func(src: mat, thresh: f32, max-value: f32, threshold-type: threshold-type)
//	-> result<mat, error-result>
//
//go:nosplit
func Threshold(src Mat, thresh float32, maxValue float32, thresholdType ThresholdType) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	thresh0 := (float32)(thresh)
	maxValue0 := (float32)(maxValue)
	thresholdType0 := (uint32)(thresholdType)
	wasmimport_Threshold((uint32)(src0), (float32)(thresh0), (float32)(maxValue0), (uint32)(thresholdType0), &result)
	return
}

// TransposeND represents the imported function "transpose-ND".
//
// Transpose for n-dimensional matrices.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gab1b1274b4a563be34cdfa55b8919a4ec
//
//	transpose-ND: func(src: mat, order: list<s32>) -> result<mat, error-result>
//
//go:nosplit
func TransposeND(src Mat, order cm.List[int32]) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	order0, order1 := cm.LowerList(order)
	wasmimport_TransposeND((uint32)(src0), (*int32)(order0), (uint32)(order1), &result)
	return
}

// EstimateAffine2d represents the imported function "estimate-affine2d".
//
// estimate-affine2d computes an optimal affine transformation between two 2D point
// sets.
//
// For further details, please see:
// https://docs.opencv.org/4.0.0/d9/d0c/group__calib3d.html#ga27865b1d26bac9ce91efaee83e94d4dd
//
//	estimate-affine2d: func(frm: mat, to: mat) -> result<mat, error-result>
//
//go:nosplit
func EstimateAffine2d(frm Mat, to Mat) (result cm.Result[string, Mat, ErrorResult]) {
	frm0 := cm.Reinterpret[uint32](frm)
	to0 := cm.Reinterpret[uint32](to)
	wasmimport_EstimateAffine2d((uint32)(frm0), (uint32)(to0), &result)
	return
}

// WarpAffine represents the imported function "warp-affine".
//
// warp-affine applies an affine transformation to an image.
//
// For further details, please see:
// https://docs.opencv.org/4.x/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983
//
//	warp-affine: func(src: mat, m: mat, size: size) -> result<mat, error-result>
//
//go:nosplit
func WarpAffine(src Mat, m Mat, size Size) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	m0 := cm.Reinterpret[uint32](m)
	size0, size1 := lower_Size(size)
	wasmimport_WarpAffine((uint32)(src0), (uint32)(m0), (uint32)(size0), (uint32)(size1), &result)
	return
}

// GetRotationMatrix2d represents the imported function "get-rotation-matrix2d".
//
// get-rotation-matrix2d calculates an affine matrix of 2D rotation.
//
// For further details, please see:
// https://docs.opencv.org/4.x/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326
//
//	get-rotation-matrix2d: func(center: point, angle: f64, scale: f64) -> result<mat,
//	error-result>
//
//go:nosplit
func GetRotationMatrix2d(center Point, angle float64, scale float64) (result cm.Result[string, Mat, ErrorResult]) {
	center0, center1 := lower_Size(center)
	angle0 := (float64)(angle)
	scale0 := (float64)(scale)
	wasmimport_GetRotationMatrix2d((uint32)(center0), (uint32)(center1), (float64)(angle0), (float64)(scale0), &result)
	return
}

// Add represents the imported function "add".
//
// add calculates the per-element sum of two arrays.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6
//
//	add: func(src1: mat, src2: mat) -> result<mat, error-result>
//
//go:nosplit
func Add(src1 Mat, src2 Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src10 := cm.Reinterpret[uint32](src1)
	src20 := cm.Reinterpret[uint32](src2)
	wasmimport_Add((uint32)(src10), (uint32)(src20), &result)
	return
}

// AddWeighted represents the imported function "add-weighted".
//
// add-weighted calculates the weighted sum of two arrays.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19
//
//	add-weighted: func(src1: mat, alpha: f64, src2: mat, beta: f64, gamma: f64) ->
//	result<mat, error-result>
//
//go:nosplit
func AddWeighted(src1 Mat, alpha float64, src2 Mat, beta float64, gamma float64) (result cm.Result[string, Mat, ErrorResult]) {
	src10 := cm.Reinterpret[uint32](src1)
	alpha0 := (float64)(alpha)
	src20 := cm.Reinterpret[uint32](src2)
	beta0 := (float64)(beta)
	gamma0 := (float64)(gamma)
	wasmimport_AddWeighted((uint32)(src10), (float64)(alpha0), (uint32)(src20), (float64)(beta0), (float64)(gamma0), &result)
	return
}

// Exp represents the imported function "exp".
//
// exp calculates the exponent of every array element.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga3e10108e2162c338f1b848af619f39e5
//
//	exp: func(src: mat) -> result<mat, error-result>
//
//go:nosplit
func Exp(src Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	wasmimport_Exp((uint32)(src0), &result)
	return
}

// Hconcat represents the imported function "hconcat".
//
// hconcat applies horizontal concatenation to given matrices.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gaab5ceee39e0580f879df645a872c6bf7
//
//	hconcat: func(src1: mat, src2: mat) -> result<mat, error-result>
//
//go:nosplit
func Hconcat(src1 Mat, src2 Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src10 := cm.Reinterpret[uint32](src1)
	src20 := cm.Reinterpret[uint32](src2)
	wasmimport_Hconcat((uint32)(src10), (uint32)(src20), &result)
	return
}

// Vconcat represents the imported function "vconcat".
//
// vconcat applies vertical concatenation to given matrices.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga744f53b69f6e4f12156cdde4e76aed27
//
//	vconcat: func(src1: mat, src2: mat) -> result<mat, error-result>
//
//go:nosplit
func Vconcat(src1 Mat, src2 Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src10 := cm.Reinterpret[uint32](src1)
	src20 := cm.Reinterpret[uint32](src2)
	wasmimport_Vconcat((uint32)(src10), (uint32)(src20), &result)
	return
}

// Lut represents the imported function "lut".
//
// lut performs a look-up table transform of an array.
//
// The function LUT fills the output array with values from the look-up table.
// Indices of the entries are taken from the input array.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gab55b8d062b7f5587720ede032d34156f
//
//	lut: func(src: mat, wblut: mat) -> result<mat, error-result>
//
//go:nosplit
func Lut(src Mat, wblut Mat) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	wblut0 := cm.Reinterpret[uint32](wblut)
	wasmimport_Lut((uint32)(src0), (uint32)(wblut0), &result)
	return
}

// Reduce represents the imported function "reduce".
//
// reduce reduces the matrix to a vector.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga4b78072a303f29d9031d56e5638da78e
//
//	reduce: func(src: mat, dim: u32, reduce-type: u32, depth-type: u32) -> result<mat,
//	error-result>
//
//go:nosplit
func Reduce(src Mat, dim uint32, reduceType uint32, depthType uint32) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	dim0 := (uint32)(dim)
	reduceType0 := (uint32)(reduceType)
	depthType0 := (uint32)(depthType)
	wasmimport_Reduce((uint32)(src0), (uint32)(dim0), (uint32)(reduceType0), (uint32)(depthType0), &result)
	return
}

// ReduceArgMax represents the imported function "reduce-arg-max".
//
// reduce-arg-max finds indices of max elements along provided axis.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gaa87ea34d99bcc5bf9695048355163da0
//
//	reduce-arg-max: func(src: mat, axis: u32, last-index: bool) -> result<mat, error-result>
//
//go:nosplit
func ReduceArgMax(src Mat, axis uint32, lastIndex bool) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	axis0 := (uint32)(axis)
	lastIndex0 := (uint32)(cm.BoolToU32(lastIndex))
	wasmimport_ReduceArgMax((uint32)(src0), (uint32)(axis0), (uint32)(lastIndex0), &result)
	return
}

// Normalize represents the imported function "normalize".
//
// normalize normalizes the norm or value range of an array.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga87eef7ee3970f86906d69a92cbf064bd
//
//	normalize: func(src: mat, alpha: f32, beta: f32, norm-type: u32) -> result<mat,
//	error-result>
//
//go:nosplit
func Normalize(src Mat, alpha float32, beta float32, normType uint32) (result cm.Result[string, Mat, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	alpha0 := (float32)(alpha)
	beta0 := (float32)(beta)
	normType0 := (uint32)(normType)
	wasmimport_Normalize((uint32)(src0), (float32)(alpha0), (float32)(beta0), (uint32)(normType0), &result)
	return
}

// Norm represents the imported function "norm".
//
// norm calculates the norm of an array.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga7c331fb8dd951707e184ef4e3f21dd33
//
//	norm: func(src: mat, norm-type: u32) -> result<f32, error-result>
//
//go:nosplit
func Norm(src Mat, normType uint32) (result cm.Result[string, float32, ErrorResult]) {
	src0 := cm.Reinterpret[uint32](src)
	normType0 := (uint32)(normType)
	wasmimport_Norm((uint32)(src0), (uint32)(normType0), &result)
	return
}
