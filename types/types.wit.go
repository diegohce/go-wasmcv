// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package types represents the imported interface "wasm:cv/types".
package types

import (
	"go.bytecodealliance.org/cm"
)

// ErrorResult represents the string "wasm:cv/types#error-result".
//
//	type error-result = string
type ErrorResult string

// Size represents the record "wasm:cv/types#size".
//
// size is a 2-element integer vector.
// It represents a width and height.
//
//	record size {
//		x: s32,
//		y: s32,
//	}
type Size struct {
	_ cm.HostLayout `json:"-"`
	X int32         `json:"x"`
	Y int32         `json:"y"`
}

// Point represents the type alias "wasm:cv/types#point".
//
// See [Size] for more information.
type Point = Size

// Scalar represents the record "wasm:cv/types#scalar".
//
// scalar is a 4-element floating point vector.
//
//	record scalar {
//		val1: f32,
//		val2: f32,
//		val3: f32,
//		val4: f32,
//	}
type Scalar struct {
	_    cm.HostLayout `json:"-"`
	Val1 float32       `json:"val1"`
	Val2 float32       `json:"val2"`
	Val3 float32       `json:"val3"`
	Val4 float32       `json:"val4"`
}

// Rect represents the record "wasm:cv/types#rect".
//
// rect is a rectangle with integer coordinates.
// It is represented by the top-left corner and the bottom-right corner.
//
//	record rect {
//		min: size,
//		max: size,
//	}
type Rect struct {
	_   cm.HostLayout `json:"-"`
	Min Size          `json:"min"`
	Max Size          `json:"max"`
}

// RGBA represents the record "wasm:cv/types#RGBA".
//
// RGBA is a color with red, green, blue, and alpha channels.
//
//	record RGBA {
//		r: u8,
//		g: u8,
//		b: u8,
//		a: u8,
//	}
type RGBA struct {
	_ cm.HostLayout `json:"-"`
	R uint8         `json:"r"`
	G uint8         `json:"g"`
	B uint8         `json:"b"`
	A uint8         `json:"a"`
}

// BorderType represents the enum "wasm:cv/types#border-type".
//
// border-type is a type of border to add to an image.
//
//	enum border-type {
//		border-constant,
//		border-replicate,
//		border-reflect,
//		border-wrap,
//		border-reflect101,
//		border-transparent,
//		border-default,
//		border-isolated
//	}
type BorderType uint8

const (
	BorderTypeBorderConstant BorderType = iota
	BorderTypeBorderReplicate
	BorderTypeBorderReflect
	BorderTypeBorderWrap
	BorderTypeBorderReflect101
	BorderTypeBorderTransparent
	BorderTypeBorderDefault
	BorderTypeBorderIsolated
)

var _BorderTypeStrings = [8]string{
	"border-constant",
	"border-replicate",
	"border-reflect",
	"border-wrap",
	"border-reflect101",
	"border-transparent",
	"border-default",
	"border-isolated",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e BorderType) String() string {
	return _BorderTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e BorderType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *BorderType) UnmarshalText(text []byte) error {
	return _BorderTypeUnmarshalCase(e, text)
}

var _BorderTypeUnmarshalCase = cm.CaseUnmarshaler[BorderType](_BorderTypeStrings[:])

// AdaptiveThresholdType represents the enum "wasm:cv/types#adaptive-threshold-type".
//
// adaptive-threshold-type is a type of adaptive thresholding.
//
//	enum adaptive-threshold-type {
//		adaptive-threshold-mean,
//		adaptive-threshold-gaussian
//	}
type AdaptiveThresholdType uint8

const (
	AdaptiveThresholdTypeAdaptiveThresholdMean AdaptiveThresholdType = iota
	AdaptiveThresholdTypeAdaptiveThresholdGaussian
)

var _AdaptiveThresholdTypeStrings = [2]string{
	"adaptive-threshold-mean",
	"adaptive-threshold-gaussian",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e AdaptiveThresholdType) String() string {
	return _AdaptiveThresholdTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e AdaptiveThresholdType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *AdaptiveThresholdType) UnmarshalText(text []byte) error {
	return _AdaptiveThresholdTypeUnmarshalCase(e, text)
}

var _AdaptiveThresholdTypeUnmarshalCase = cm.CaseUnmarshaler[AdaptiveThresholdType](_AdaptiveThresholdTypeStrings[:])

// ThresholdType represents the enum "wasm:cv/types#threshold-type".
//
// threshold-type is a type of thresholding.
//
//	enum threshold-type {
//		threshold-binary,
//		threshold-binary-inv,
//		threshold-trunc,
//		threshold-to-zero,
//		threshold-to-zero-inv,
//		threshold-mask,
//		threshold-otsu,
//		tthreshold-triangle
//	}
type ThresholdType uint8

const (
	ThresholdTypeThresholdBinary ThresholdType = iota
	ThresholdTypeThresholdBinaryInv
	ThresholdTypeThresholdTrunc
	ThresholdTypeThresholdToZero
	ThresholdTypeThresholdToZeroInv
	ThresholdTypeThresholdMask
	ThresholdTypeThresholdOtsu
	ThresholdTypeTthresholdTriangle
)

var _ThresholdTypeStrings = [8]string{
	"threshold-binary",
	"threshold-binary-inv",
	"threshold-trunc",
	"threshold-to-zero",
	"threshold-to-zero-inv",
	"threshold-mask",
	"threshold-otsu",
	"tthreshold-triangle",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e ThresholdType) String() string {
	return _ThresholdTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e ThresholdType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *ThresholdType) UnmarshalText(text []byte) error {
	return _ThresholdTypeUnmarshalCase(e, text)
}

var _ThresholdTypeUnmarshalCase = cm.CaseUnmarshaler[ThresholdType](_ThresholdTypeStrings[:])

// DataLayoutType represents the enum "wasm:cv/types#data-layout-type".
//
// data-layout-type is a type of data layout.
//
//	enum data-layout-type {
//		data-layout-unknown,
//		data-layout-nd,
//		data-layout-nchw,
//		data-layout-ncdhw,
//		data-layout-nhwc,
//		data-layout-ndhwc,
//		data-layout-planar
//	}
type DataLayoutType uint8

const (
	DataLayoutTypeDataLayoutUnknown DataLayoutType = iota
	DataLayoutTypeDataLayoutNd
	DataLayoutTypeDataLayoutNchw
	DataLayoutTypeDataLayoutNcdhw
	DataLayoutTypeDataLayoutNhwc
	DataLayoutTypeDataLayoutNdhwc
	DataLayoutTypeDataLayoutPlanar
)

var _DataLayoutTypeStrings = [7]string{
	"data-layout-unknown",
	"data-layout-nd",
	"data-layout-nchw",
	"data-layout-ncdhw",
	"data-layout-nhwc",
	"data-layout-ndhwc",
	"data-layout-planar",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e DataLayoutType) String() string {
	return _DataLayoutTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e DataLayoutType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *DataLayoutType) UnmarshalText(text []byte) error {
	return _DataLayoutTypeUnmarshalCase(e, text)
}

var _DataLayoutTypeUnmarshalCase = cm.CaseUnmarshaler[DataLayoutType](_DataLayoutTypeStrings[:])

// PaddingModeType represents the enum "wasm:cv/types#padding-mode-type".
//
//	enum padding-mode-type {
//		padding-mode-null,
//		padding-mode-crop-center,
//		padding-mode-letterbox
//	}
type PaddingModeType uint8

const (
	PaddingModeTypePaddingModeNull PaddingModeType = iota
	PaddingModeTypePaddingModeCropCenter
	PaddingModeTypePaddingModeLetterbox
)

var _PaddingModeTypeStrings = [3]string{
	"padding-mode-null",
	"padding-mode-crop-center",
	"padding-mode-letterbox",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e PaddingModeType) String() string {
	return _PaddingModeTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e PaddingModeType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *PaddingModeType) UnmarshalText(text []byte) error {
	return _PaddingModeTypeUnmarshalCase(e, text)
}

var _PaddingModeTypeUnmarshalCase = cm.CaseUnmarshaler[PaddingModeType](_PaddingModeTypeStrings[:])

// BlobParams represents the record "wasm:cv/types#blob-params".
//
//	record blob-params {
//		scale-factor: f32,
//		size: size,
//		mean: scalar,
//		swap-RB: bool,
//		ddepth: u8,
//		data-layout: data-layout-type,
//		padding-mode: padding-mode-type,
//		border: scalar,
//	}
type BlobParams struct {
	_           cm.HostLayout   `json:"-"`
	ScaleFactor float32         `json:"scale-factor"`
	Size        Size            `json:"size"`
	Mean        Scalar          `json:"mean"`
	SwapRB      bool            `json:"swap-RB"`
	Ddepth      uint8           `json:"ddepth"`
	DataLayout  DataLayoutType  `json:"data-layout"`
	PaddingMode PaddingModeType `json:"padding-mode"`
	Border      Scalar          `json:"border"`
}

// MixMaxLocResult represents the record "wasm:cv/types#mix-max-loc-result".
//
//	record mix-max-loc-result {
//		min-val: f32,
//		max-val: f32,
//		min-loc: size,
//		max-loc: size,
//	}
type MixMaxLocResult struct {
	_      cm.HostLayout `json:"-"`
	MinVal float32       `json:"min-val"`
	MaxVal float32       `json:"max-val"`
	MinLoc Size          `json:"min-loc"`
	MaxLoc Size          `json:"max-loc"`
}

// HersheyFontType represents the enum "wasm:cv/types#hershey-font-type".
//
//	enum hershey-font-type {
//		hershey-font-simplex,
//		hershey-font-plain,
//		hershey-font-duplex,
//		hershey-font-complex,
//		hershey-font-triplex,
//		hershey-font-complex-small,
//		hershey-font-script-simplex,
//		hershey-font-script-complex,
//		hershey-font-italic
//	}
type HersheyFontType uint8

const (
	HersheyFontTypeHersheyFontSimplex HersheyFontType = iota
	HersheyFontTypeHersheyFontPlain
	HersheyFontTypeHersheyFontDuplex
	HersheyFontTypeHersheyFontComplex
	HersheyFontTypeHersheyFontTriplex
	HersheyFontTypeHersheyFontComplexSmall
	HersheyFontTypeHersheyFontScriptSimplex
	HersheyFontTypeHersheyFontScriptComplex
	HersheyFontTypeHersheyFontItalic
)

var _HersheyFontTypeStrings = [9]string{
	"hershey-font-simplex",
	"hershey-font-plain",
	"hershey-font-duplex",
	"hershey-font-complex",
	"hershey-font-triplex",
	"hershey-font-complex-small",
	"hershey-font-script-simplex",
	"hershey-font-script-complex",
	"hershey-font-italic",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e HersheyFontType) String() string {
	return _HersheyFontTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e HersheyFontType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *HersheyFontType) UnmarshalText(text []byte) error {
	return _HersheyFontTypeUnmarshalCase(e, text)
}

var _HersheyFontTypeUnmarshalCase = cm.CaseUnmarshaler[HersheyFontType](_HersheyFontTypeStrings[:])

// InterpolationType represents the enum "wasm:cv/types#interpolation-type".
//
//	enum interpolation-type {
//		interpolation-nearest,
//		interpolation-linear,
//		interpolation-cubic,
//		interpolation-area,
//		interpolation-lanczos4
//	}
type InterpolationType uint8

const (
	InterpolationTypeInterpolationNearest InterpolationType = iota
	InterpolationTypeInterpolationLinear
	InterpolationTypeInterpolationCubic
	InterpolationTypeInterpolationArea
	InterpolationTypeInterpolationLanczos4
)

var _InterpolationTypeStrings = [5]string{
	"interpolation-nearest",
	"interpolation-linear",
	"interpolation-cubic",
	"interpolation-area",
	"interpolation-lanczos4",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e InterpolationType) String() string {
	return _InterpolationTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e InterpolationType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *InterpolationType) UnmarshalText(text []byte) error {
	return _InterpolationTypeUnmarshalCase(e, text)
}

var _InterpolationTypeUnmarshalCase = cm.CaseUnmarshaler[InterpolationType](_InterpolationTypeStrings[:])

// ColorCoversionType represents the enum "wasm:cv/types#color-coversion-type".
//
//	enum color-coversion-type {
//		color-BGR-to-BGRA,
//		color-RGB-to-RGBA,
//		color-BGRA-to-BGR,
//		color-RGBA-to-RGB,
//		color-BGR-to-RGBA,
//		color-RGB-to-BGRA,
//		color-RGBA-to-BGR,
//		color-BGRA-to-RGB,
//		color-BGR-to-RGB,
//		color-RGB-to-BGR,
//		color-BGRA-to-RGBA,
//		color-RGBA-to-BGRA,
//		color-BGR-to-gray,
//		color-RGB-to-gray,
//		color-gray-to-BGR,
//		color-gray-to-RGB,
//		color-gray-to-BGRA,
//		color-gray-to-RGBA,
//		color-BGRA-to-gray,
//		color-RGBA-to-gray
//	}
type ColorCoversionType uint8

const (
	ColorCoversionTypeColorBGRToBGRA ColorCoversionType = iota
	ColorCoversionTypeColorRGBToRGBA
	ColorCoversionTypeColorBGRAToBGR
	ColorCoversionTypeColorRGBAToRGB
	ColorCoversionTypeColorBGRToRGBA
	ColorCoversionTypeColorRGBToBGRA
	ColorCoversionTypeColorRGBAToBGR
	ColorCoversionTypeColorBGRAToRGB
	ColorCoversionTypeColorBGRToRGB
	ColorCoversionTypeColorRGBToBGR
	ColorCoversionTypeColorBGRAToRGBA
	ColorCoversionTypeColorRGBAToBGRA
	ColorCoversionTypeColorBGRToGray
	ColorCoversionTypeColorRGBToGray
	ColorCoversionTypeColorGrayToBGR
	ColorCoversionTypeColorGrayToRGB
	ColorCoversionTypeColorGrayToBGRA
	ColorCoversionTypeColorGrayToRGBA
	ColorCoversionTypeColorBGRAToGray
	ColorCoversionTypeColorRGBAToGray
)

var _ColorCoversionTypeStrings = [20]string{
	"color-BGR-to-BGRA",
	"color-RGB-to-RGBA",
	"color-BGRA-to-BGR",
	"color-RGBA-to-RGB",
	"color-BGR-to-RGBA",
	"color-RGB-to-BGRA",
	"color-RGBA-to-BGR",
	"color-BGRA-to-RGB",
	"color-BGR-to-RGB",
	"color-RGB-to-BGR",
	"color-BGRA-to-RGBA",
	"color-RGBA-to-BGRA",
	"color-BGR-to-gray",
	"color-RGB-to-gray",
	"color-gray-to-BGR",
	"color-gray-to-RGB",
	"color-gray-to-BGRA",
	"color-gray-to-RGBA",
	"color-BGRA-to-gray",
	"color-RGBA-to-gray",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e ColorCoversionType) String() string {
	return _ColorCoversionTypeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e ColorCoversionType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *ColorCoversionType) UnmarshalText(text []byte) error {
	return _ColorCoversionTypeUnmarshalCase(e, text)
}

var _ColorCoversionTypeUnmarshalCase = cm.CaseUnmarshaler[ColorCoversionType](_ColorCoversionTypeStrings[:])

// MorphShape represents the enum "wasm:cv/types#morph-shape".
//
//	enum morph-shape {
//		morph-rect,
//		morph-cross,
//		morph-ellipse
//	}
type MorphShape uint8

const (
	MorphShapeMorphRect MorphShape = iota
	MorphShapeMorphCross
	MorphShapeMorphEllipse
)

var _MorphShapeStrings = [3]string{
	"morph-rect",
	"morph-cross",
	"morph-ellipse",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e MorphShape) String() string {
	return _MorphShapeStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e MorphShape) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *MorphShape) UnmarshalText(text []byte) error {
	return _MorphShapeUnmarshalCase(e, text)
}

var _MorphShapeUnmarshalCase = cm.CaseUnmarshaler[MorphShape](_MorphShapeStrings[:])

// KeyPoint represents the record "wasm:cv/types#key-point".
//
//	record key-point {
//		x: f32,
//		y: f32,
//		size: f32,
//		angle: f32,
//		response: f32,
//		octave: s32,
//		class-id: s32,
//	}
type KeyPoint struct {
	_        cm.HostLayout `json:"-"`
	X        float32       `json:"x"`
	Y        float32       `json:"y"`
	Size     float32       `json:"size"`
	Angle    float32       `json:"angle"`
	Response float32       `json:"response"`
	Octave   int32         `json:"octave"`
	ClassID  int32         `json:"class-id"`
}

// DMatch represents the record "wasm:cv/types#d-match".
//
// DMatch is data structure for matching keypoint descriptors.
//
// For further details, please see:
// https://docs.opencv.org/4.x/d4/de0/classcv_1_1DMatch.html#a546ddb9a87898f06e510e015a6de596e
//
//	record d-match {
//		query-idx: u32,
//		train-idx: u32,
//		img-idx: u32,
//		distance: f64,
//	}
type DMatch struct {
	_        cm.HostLayout `json:"-"`
	QueryIdx uint32        `json:"query-idx"`
	TrainIdx uint32        `json:"train-idx"`
	ImgIdx   uint32        `json:"img-idx"`
	Distance float64       `json:"distance"`
}
